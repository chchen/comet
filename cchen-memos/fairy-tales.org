* Fairy Tale Diary

** 13 November 2019

*** Part One

System designers face a dilemma: specify your programs at a high
level, and you have a chance of ruling out certain bugs because of
things like type checking. If you're so inclined, you can even prove
interesting theorems about the programs you write. But often you're
faced with two problems:

1. Your programs are slow, because details about the underlying
   hardware aren't available.
2. Your programs are insecure, because most high level abstractions
   aren't carried down to hardware.

This is really sad. And the alternative, writing our programs in
low-level machine code, also hurts because we're prone to write bugs,
and analysis becomes harder. It's harder because the language has less
structure: fewer types, fewer avenues for analysis.

What if there was a way to project the *right* abstractions from a
machine specification such that we have a hope for preserving
guarantees? Maybe we could expose places where the abstractions may be
broken, but as long as we annotate them, we're ok, sort of like the
unsafe annotations in Java and Rust. Then we could imagine a method
for translating our annotated programs to machine code in a way that
sandboxes the unsafe code from the safe code.

I'm proposing synthesis, but of languages.

And we can take it one step further: we can take our machine
specification and break it into subspecifications: the "clean" ALU
operations, memory operations, page table operations, IO operations,
etc. Each of these sublanguages can be the source from which we
project a variety of DSLs where we can make some serious guarantees
about behaviour and performance. And if we have a reasoned method for
talking about composing these languages (I don't want to say "linking"
but that's close), maybe we can build safe and fast systems.

*** Part Two

We spend a lot of time managing the variable names in the
specification language and the target language. Right now we have a
deterministic algorithm that gives us a mapping. I'm not sure if
that's what we really want. For instance, if we were emitting assembly
code, how would we map between a symbolic variable name "x" in UNITY
and some symbol in assembly? This seems an awful lot like a
compilation problem.

** 14 November 2019

Here's another idea. Doing proofs about programs is hard, and the
payoff is pretty small: you only know facts about that particular
program. But what if we did proofs about *schemas* of programs? Then
we know facts about whole classes of programs and we can devise
methods for validating the schema. Maybe, what we can do, is build
proofs about DSLs before releasing them into the wild. OR perhaps, we
could define some minimal core OS, then admit different DSLs into the
operating environment, with each DSL accompanied with proofs of
correctness. Proof-carrying languages, you see.

** 15 November 2019

Mark mentioned an idea that I will attempt to paraphrase here. Given
an existing language, maybe what we want to do is identify particular
idioms that exist in that language and reason about them. If you're
uncomfortable with the term "idioms", then just say macros, except
that these

** 6 December 2019

As of today, we can synthesize a small distributed system from a high
level specification, written in UNITY. Our next step is to do a
non-trivial implementation of single-round Paxos in UNITY, then
synthesize to a mixed cluster of FPGAs and Arduinos.

This poses a few challenges:

1. Prove correctness theorems about the UNITY specification. Can we do
   this with automated SMT theorem proving? Do we need to use
   inductive proofs?
2. Prove that the synthesized programs for Arduino or the FPGA are
   indeed refinements of the UNITY spec. In some way, this requires us
   to show that the way we've broken down the UNITY spec into smaller
   synthesis challenges is sound.
3. Handle bigger synthesis challenges. We're moving from boolean
   values into bitvectors or small integers. This makes the search
   space bigger for synthesis. Can we find ways to constrain the
   search space to allow us to synthesize programs without as much
   templating?

At the end of this exercise, we hope to have built a system for
constructing a non-trivial distributed system that's correct by
construction, and from a language that makes automated reasoning
tractable.

Next steps: Can we imagine a method for inferring the specification
from a even higher level protocol spec, or from examples?
