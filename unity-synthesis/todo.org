* Synthesis todo: cchen

- Type checking predicate doesn't work with synthesis. Why?

Right now the interpreter doesn't bubble up type environment errors,
which means we have a bug where we can admit "weird" programs, like
those that refer to invalid variables. This is also bad because it
allows for a larger number of candidate programs (making synthesis
slow) since our expression and statement generators allow for all
allowed pin indentifiers, not just those that are initialized in the
setup section.

We tried to work around this by defining a type/syntax check function,
that would take a expression/statement and a type environment, and
check to make sure the expression/statement was well-typed. For
whatever reason, handing off (and (valid-expression? exp env)...) to
synthesis leads to a an unsatisfiable result. There's probably
something in how the checker is written that borks the synthesis
process.

We could dig deeper into this, or we can try and use (choose*) instead
of (choose) and build our recursive syntaxes functionally using
(define) rather than with (define-synthax) that uses macros.

I ended up doing this and it seems to work well. I've switched the
declaration, statement, and expression generators now.

Barring that, we can clean up the interpreters to actually return
dynamic type errors when they occur (may actually do, or remove the
error checks to make cleaner)

- Context translation from UNITY to Verilog (ok)
- Symbolic state generator for Verilog (ok)
- State equivalence between UNITY and Verilog (ok)
- Synthesize verilog declarations (inversion on declarations)

I think we can compile them from the context declaration for now.

- Modify synthesis routines to use shiny new stuff

We still have the issue where we need to make sure the verilog
symbolic states are the same as the unity symbolic states for
synthesis. (done)

- Syntax and semantics for Verilog triggers (not needed?)

Verilog triggers are both discrete events (posedge/negedge) and states
('clk -> #t). So in order to support triggers, we need to be able to
provide the discrete events as arguments to the interpreter, and
assert the values in the state mapping. This should be okay since our
new state equivalence function only concerns itself with variables
defined in the UNITY program, so variables that are only defined in
the Verilog program like reset and clock are ignored. I don't think we
need to add any additional things to the syntax and semantics, but we
just need to make sure that we construct the Verilog state mappings
the correct way, which I think means adding reset and clock to every
program's input and wire contexts.

- Add assertions to make sure synthesis is correct
- Backend for Arduino and Verilog syntax
