* Synthesis todo: cchen

** Type checking predicate doesn't work with synthesis. Why?

Right now the interpreter doesn't bubble up type environment errors,
which means we have a bug where we can admit "weird" programs, like
those that refer to invalid variables. This is also bad because it
allows for a larger number of candidate programs (making synthesis
slow) since our expression and statement generators allow for all
allowed pin indentifiers, not just those that are initialized in the
setup section.

We tried to work around this by defining a type/syntax check function,
that would take a expression/statement and a type environment, and
check to make sure the expression/statement was well-typed. For
whatever reason, handing off (and (valid-expression? exp env)...) to
synthesis leads to a an unsatisfiable result. There's probably
something in how the checker is written that borks the synthesis
process.

We could dig deeper into this, or we can try and use (choose*) instead
of (choose) and build our recursive syntaxes functionally using
(define) rather than with (define-synthax) that uses macros.

I ended up doing this and it seems to work well. I've switched the
declaration, statement, and expression generators now.

Barring that, we can clean up the interpreters to actually return
dynamic type errors when they occur (may actually do, or remove the
error checks to make cleaner)

** Context translation from UNITY to Verilog (ok)
** Symbolic state generator for Verilog (ok)
** State equivalence between UNITY and Verilog (ok)
** Synthesize verilog declarations (inversion on declarations)

I think we can compile them from the context declaration for now.

** Modify synthesis routines to use shiny new stuff

We still have the issue where we need to make sure the verilog
symbolic states are the same as the unity symbolic states for
synthesis. (done)

** Syntax and semantics for Verilog triggers (not needed?)

Verilog triggers are both discrete events (posedge/negedge) and states
('clk -> #t). So in order to support triggers, we need to be able to
provide the discrete events as arguments to the interpreter, and
assert the values in the state mapping. This should be okay since our
new state equivalence function only concerns itself with variables
defined in the UNITY program, so variables that are only defined in
the Verilog program like reset and clock are ignored. I don't think we
need to add any additional things to the syntax and semantics, but we
just need to make sure that we construct the Verilog state mappings
the correct way, which I think means adding reset and clock to every
program's input and wire contexts.

** Add assertions to make sure synthesis is correct

This means finishing up the verilog module interpreter, and maybe
cleaning up the way we generate contexts, etc. Right now we pass the
context into the state-get function, which makes for some awkward
usage. Perhaps we should scrap the dynamic checks in state-get to
allow us to intropect the state without having the context at
hand. YAGNI, you know.

** Synthesized program verification

- Verilog interpret for reset === UNITY interpret for initially: works, sorta!
- Verilog interpret for clock === UNITY interpret for assign: doesn't work yet: we get a symbolic formula that's unsat

** Backend for Arduino and Verilog syntax

Verilog syntax (OK)
Arduino syntax (todo)

Expressions turn into single strings, recursively, that's fine.
Statements are sequences of statements, which mean they're tree like,
so we have to flatten them somehow, and join them with a
newline. Right now emit-statements doesn't quite work. But we're close.

Foldr with string-append is your friend

** Try specifying different things in UNITY

- Synthesize a stupid simple Arduino-FPGA communicating system: bit toggle
  1. Single UNITY toggle spec (done!)
  2. Emit Arduino syntax (done!)
  3. Synthesize Arduino and Verilog implementations, lining up
     variables so inputs line up with outputs (done!)
  4. Program it in one go (done!)

** Incomplete Arduino Support

- We don't fully support variables in our model: declaration, etc.
- Right now we just allocate Arduino I/O pins starting from Digital 0, going on up. Is this OK?
